#
# @lc app=leetcode.cn id=3 lang=python3
#
# [3] 无重复字符的最长子串
#

# @lc code=start
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

    # ========================

    # 提示: 

    ## 如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的
    ## 这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k 。
    ## 那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 r_k 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 r_k ，直到右侧出现了重复字符为止。

    # ========================

    # 思路: 

    ## 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 r_k 

    ## 在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

    ## 在枚举结束后，我们找到的最长的子串的长度即为答案。

    # ========================

        # # 哈希集合 存储每个字符是否出现过 
        # occ = set()

        # # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        # rk, ans = -1, 0 

        # # 枚举左指针的位置 寻找最长无重复字符子串
        # for i in range(len(s)): 
        #     # 左指针向右移动一格，移除一个字符
        #     if i != 0 : 
        #         occ.remove(s[i-1])
        #     # 不断移动右指针
        #     while ( rk + 1 < len(s) ) and ( s[rk+1] not in occ ): 
        #         occ.add(s[rk+1])
        #         rk += 1 
        #     # 第 i 到 rk 个字符是一个极长的无重复字符子串
        #     ans = max(ans, rk - i + 1)

        # return ans

        ans = 0
        curstr = '' # 用于提取一个子串 每个字符只出现一次且保持顺序 相当于对无重复字符的切片作遍历
        
        # 对于每一个字符
        for i in s: 
            # 如果 i 不在当前子串中，则添加到子串中，并更新答案
            if i not in curstr: 
                curstr = curstr + i
                ans = max(ans, len(curstr))
            # 如果 i 在当前子串中，则从当前子串中删除 i 之前的字符，并添加 i
            else: 
                while curstr and curstr[0] != i:
                    curstr = curstr[1:]
                curstr = curstr[1:] + i
        
        return ans

# @lc code=end

